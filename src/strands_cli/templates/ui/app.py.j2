"""
Streamlit UI for testing Strands agents.

This Streamlit app provides a chat interface for interacting with Strands agents,
supporting both streaming and non-streaming responses.
"""

import os
import requests
import json
import time
from typing import Dict, Any, List, Optional

import streamlit as st

# Set page configuration
st.set_page_config(
    page_title="Strands Agent Chat",
    page_icon="ðŸ¤–",
    layout="centered",
    initial_sidebar_state="collapsed",
)

# Custom CSS for better markdown rendering
st.markdown("""
<style>
.stMarkdown {
    font-family: 'Source Sans Pro', sans-serif;
}
.stMarkdown h1, .stMarkdown h2, .stMarkdown h3, .stMarkdown h4 {
    font-weight: 600;
    margin-top: 1em;
    margin-bottom: 0.5em;
}
.stMarkdown ul, .stMarkdown ol {
    padding-left: 20px;
    margin-bottom: 1em;
}
.stMarkdown li {
    margin-bottom: 0.5em;
}
.stMarkdown code {
    background-color: #f0f2f6;
    padding: 2px 4px;
    border-radius: 3px;
}
.stMarkdown pre code {
    display: block;
    padding: 10px;
    white-space: pre-wrap;
    background-color: #f0f2f6;
    border-radius: 4px;
    margin-bottom: 1em;
}
</style>
""", unsafe_allow_html=True)

# Constants and configuration
AGENT_URL = os.environ.get("AGENT_URL", "http://localhost:8000")


def initialize_session_state():
    """Initialize session state variables."""
    if "messages" not in st.session_state:
        st.session_state.messages = []
    if "is_processing" not in st.session_state:
        st.session_state.is_processing = False


def add_message(role: str, content: str):
    """Add a message to the chat history.

    Args:
        role: Either "user" or "assistant"
        content: The message content
    """
    st.session_state.messages.append({"role": role, "content": content})


def format_markdown(text):
    """Format text with minimal preprocessing to let Streamlit handle markdown rendering.

    Args:
        text: The markdown text to format

    Returns:
        Lightly processed markdown text
    """
    # Simple normalization of line endings
    text = text.replace('\r\n', '\n')

    # Let Streamlit handle the markdown parsing directly
    return text


def display_message(message: Dict[str, str]):
    """Display a message in the chat UI.

    Args:
        message: A dict with 'role' and 'content' keys
    """
    if message["role"] == "user":
        with st.chat_message("user", avatar="ðŸ§‘"):
            st.markdown(message["content"])
    else:
        with st.chat_message("assistant", avatar="ðŸ¤–"):
            content = message["content"]
            # Format the markdown for better rendering
            formatted_content = format_markdown(content)
            try:
                st.markdown(formatted_content)
            except Exception:
                # Fall back to code block if markdown rendering fails
                st.code(content)


def display_chat_history():
    """Display the complete chat history."""
    for message in st.session_state.messages:
        display_message(message)


def call_agent_streaming(prompt: str) -> None:
    """Call the agent API with streaming response.

    Args:
        prompt: The user's prompt
    """
    # Create the message placeholder
    with st.chat_message("assistant", avatar="ðŸ¤–"):
        message_placeholder = st.empty()
        full_response = ""

        # Use the shared format_markdown function defined above

        # Call the streaming endpoint
        try:
            url = f"{AGENT_URL}/process-streaming"

            with requests.post(
                url,
                json={"prompt": prompt},
                stream=True,
                headers={"Content-Type": "application/json"},
            ) as response:
                response.raise_for_status()

                buffer = ""
                # Process the streaming response
                for line in response.iter_lines():
                    if line:
                        decoded_line = line.decode("utf-8")
                        # Skip the initial message if it's the standard start message
                        if "Starting response stream..." in decoded_line:
                            continue

                        # Add the decoded line to full response
                        full_response += decoded_line

                        # Format the markdown properly
                        formatted_response = format_markdown(full_response)

                        # Apply markdown formatting and add a cursor to show typing
                        try:
                            message_placeholder.markdown(formatted_response + "â–Œ")
                        except Exception:
                            # Fallback to plain text if markdown rendering fails
                            message_placeholder.code(full_response + "â–Œ")

                # Final update without the cursor
                if full_response:
                    # Format the markdown properly for final display
                    formatted_response = format_markdown(full_response)
                    try:
                        message_placeholder.markdown(formatted_response)
                    except Exception:
                        # Use code block as fallback for better formatting
                        message_placeholder.code(full_response)

        except requests.RequestException as e:
            error_message = f"âš ï¸ Connection error when calling agent API: {str(e)}"
            st.error(error_message)
            message_placeholder.markdown(error_message)
            full_response = error_message
        except Exception as e:
            error_message = f"âš ï¸ Error: {str(e)}"
            st.error(error_message)
            message_placeholder.markdown(error_message)
            full_response = error_message

        # Add the assistant's response to the history
        add_message("assistant", full_response)


def call_agent_non_streaming(prompt: str) -> None:
    """Call the agent API with non-streaming response.

    Args:
        prompt: The user's prompt
    """
    with st.chat_message("assistant", avatar="ðŸ¤–"):
        with st.spinner("Thinking..."):
            try:
                # Call the non-streaming endpoint
                response = requests.post(
                    f"{AGENT_URL}/process",
                    json={"prompt": prompt},
                    headers={"Content-Type": "application/json"},
                )
                response.raise_for_status()

                # Get the response text
                content = response.text

                # Format and display the response
                formatted_content = format_markdown(content)
                try:
                    st.markdown(formatted_content)
                except Exception:
                    st.code(content)

                # Add the assistant's response to the history
                add_message("assistant", content)

            except requests.RequestException as e:
                error_message = f"âš ï¸ Connection error when calling agent API: {str(e)}"
                st.error(error_message)
                add_message("assistant", error_message)
            except Exception as e:
                error_message = f"âš ï¸ Error: {str(e)}"
                st.error(error_message)
                add_message("assistant", error_message)


def check_agent_health() -> bool:
    """Check if the agent is healthy and ready to accept requests.

    Returns:
        bool: True if agent is healthy, False otherwise
    """
    try:
        response = requests.get(f"{AGENT_URL}/health", timeout=3)
        if response.status_code == 200:
            return True
        else:
            return False
    except requests.RequestException:
        return False
    except Exception:
        return False


def wait_for_agent(timeout: int = 30) -> bool:
    """Wait for the agent to become available.

    Args:
        timeout: Maximum time to wait in seconds

    Returns:
        bool: True if agent became available, False if timed out
    """
    start_time = time.time()
    while time.time() - start_time < timeout:
        if check_agent_health():
            return True
        time.sleep(1)
    return False


def main():
    """Main function to run the Streamlit app."""
    initialize_session_state()

    # Check if agent is available
    if not check_agent_health():
        with st.spinner("Connecting to agent service..."):
            st.warning("Waiting for agent to become available...")
            agent_ready = wait_for_agent()
            if not agent_ready:
                st.error("Could not connect to agent. Make sure the agent service is running.")
                st.info(f"Expected agent URL: {AGENT_URL}")
                st.info("If you just started the container, please wait a moment for it to initialize.")
                st.button("Retry Connection", on_click=lambda: st.experimental_rerun())
                return

    # Title and header
    col1, col2 = st.columns([6, 1])
    with col1:
        st.title("Strands Agent Chat")
    with col2:
        st.markdown(f"<div style='text-align:right;padding-top:10px;'><a href='{AGENT_URL}' target='_blank'>API â†—</a></div>", unsafe_allow_html=True)

    st.markdown("""
    <div style="margin-bottom: 20px;">
        Interact with your Strands agent in this chat interface.
        Supports markdown formatting including <code>code</code>, lists, and headings.
    </div>
    """, unsafe_allow_html=True)

    # Display chat history
    display_chat_history()

    # Process the user's input
    if prompt := st.chat_input("Type a message..."):
        # Disable the input while processing
        st.session_state.is_processing = True

        # Display user message
        add_message("user", prompt)
        with st.chat_message("user", avatar="ðŸ§‘"):
            st.markdown(prompt)

        # Call the agent with streaming response
        try:
            call_agent_streaming(prompt)
        except Exception as e:
            st.error(f"Error processing response: {str(e)}")
        finally:
            # Re-enable input
            st.session_state.is_processing = False


if __name__ == "__main__":
    main()